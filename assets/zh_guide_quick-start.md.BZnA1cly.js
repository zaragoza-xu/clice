import{_ as e,c as i,o as t,ae as o}from"./chunks/framework.U1Gow_7P.js";const p=JSON.parse('{"title":"Quick Start","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/quick-start.md","filePath":"zh/guide/quick-start.md"}'),r={name:"zh/guide/quick-start.md"};function l(s,a,c,n,d,h){return t(),i("div",null,a[0]||(a[0]=[o('<h1 id="quick-start" tabindex="-1">Quick Start <a class="header-anchor" href="#quick-start" aria-label="Permalink to &quot;Quick Start&quot;">​</a></h1><h2 id="editor-plugins" tabindex="-1">Editor Plugins <a class="header-anchor" href="#editor-plugins" aria-label="Permalink to &quot;Editor Plugins&quot;">​</a></h2><p>clice 实现了 <a href="https://microsoft.github.io/language-server-protocol" target="_blank" rel="noreferrer">Language Server Protocol</a>，任何支持该协议的编辑器原则上均可以与 clice 一起使用，提供像 <code>code completion</code>, <code>diagnostics</code>, <code>go-to-definition</code>, 等等。</p><p>但是除了标准协议之外，clice 还支持一些协议扩展，为了更好的处理这些协议扩展以及更好的与编辑器集成。使用特定编辑器中的 clice 插件往往是更好的选择，它们大多数都是开箱即用的，并且支持 clice 的协议扩展。</p><h3 id="visual-studio-code" tabindex="-1">Visual Studio Code <a class="header-anchor" href="#visual-studio-code" aria-label="Permalink to &quot;Visual Studio Code&quot;">​</a></h3><h3 id="vim-neovim" tabindex="-1">Vim/Neovim <a class="header-anchor" href="#vim-neovim" aria-label="Permalink to &quot;Vim/Neovim&quot;">​</a></h3><h3 id="others" tabindex="-1">Others <a class="header-anchor" href="#others" aria-label="Permalink to &quot;Others&quot;">​</a></h3><p>其它的编辑器还没有可用的 clice 插件（欢迎贡献！），为了在它们中使用 clice，请自行安装 clice 并参考特定编辑器的文档关于如何使用一个语言服务器。</p><h2 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h2><p>如果你的编辑器插件负责了 clice 的下载，可以跳过这一步。</p><h3 id="download-prebuilt-binary" tabindex="-1">Download Prebuilt Binary <a class="header-anchor" href="#download-prebuilt-binary" aria-label="Permalink to &quot;Download Prebuilt Binary&quot;">​</a></h3><p>通过 Release 界面下载 clice 二进制版本。</p><h3 id="build-from-source" tabindex="-1">Build from Source <a class="header-anchor" href="#build-from-source" aria-label="Permalink to &quot;Build from Source&quot;">​</a></h3><p>自己从源码编译 clice，具体的步骤参考 <a href="./../dev/build.html">build</a>。</p><h2 id="project-setup" tabindex="-1">Project Setup <a class="header-anchor" href="#project-setup" aria-label="Permalink to &quot;Project Setup&quot;">​</a></h2><p>为了让 clice 能正确理解你的代码（例如找到头文件的位置），需要为 clice 提供一份 <code>compile_commands.json</code> 文件，也就说所谓的 <a href="https://clang.llvm.org/docs/JSONCompilationDatabase.html" target="_blank" rel="noreferrer">编译数据库</a>。编译数据库中提供了每个源文件的编译选项。</p><h3 id="cmake" tabindex="-1">CMake <a class="header-anchor" href="#cmake" aria-label="Permalink to &quot;CMake&quot;">​</a></h3><p>对于使用 cmake 的构建系统来说，在构建的时候添加 <code>-DCMAKE_EXPORT_COMPILE_COMMANDS=ON</code> 选项即可，例如</p><div class="language-cmake vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmake</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cmake -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span></span></code></pre></div><p>这会在 <code>build</code> 目录下生成一份 <code>compile_commands.json</code> 文件。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>注意：只有当 cmake 的生成器选择为 makefile 和 ninja 的时候，这个选项才有作用。对于其它生成器会忽略这个选项，也就是说无法生成编译数据库。</p></div><h3 id="bazel" tabindex="-1">Bazel <a class="header-anchor" href="#bazel" aria-label="Permalink to &quot;Bazel&quot;">​</a></h3><p>Bazel 不支持直接生成编译数据库，推荐使用 <a href="https://github.com/hedronvision/bazel-compile-commands-extractor" target="_blank" rel="noreferrer">bazel-compile-commands-extractor</a>。在安装好之后，你可以这样生成 <code>compile_commands.json</code>:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bazel</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> @hedron_compile_commands//:refresh_all</span></span></code></pre></div><h3 id="visual-studio" tabindex="-1">Visual Studio <a class="header-anchor" href="#visual-studio" aria-label="Permalink to &quot;Visual Studio&quot;">​</a></h3><p>TODO:</p><h3 id="makefile" tabindex="-1">Makefile <a class="header-anchor" href="#makefile" aria-label="Permalink to &quot;Makefile&quot;">​</a></h3><p>TODO:</p><h3 id="xmake" tabindex="-1">Xmake <a class="header-anchor" href="#xmake" aria-label="Permalink to &quot;Xmake&quot;">​</a></h3><h3 id="others-1" tabindex="-1">Others <a class="header-anchor" href="#others-1" aria-label="Permalink to &quot;Others&quot;">​</a></h3><p>对于任意其它的构建系统，可以尝试使用 <a href="https://github.com/rizsotto/Bear" target="_blank" rel="noreferrer">bear</a> 或者 <a href="https://github.com/rizsotto/scan-build" target="_blank" rel="noreferrer">scan-build</a> 来拦截编译命令并获取到编译数据库（不保证成功）。我们计划在未来编写一个<strong>新的工具</strong>，通过假编译器的方式来实现编译命令的捕获。</p>',31)]))}const m=e(r,[["render",l]]);export{p as __pageData,m as default};
