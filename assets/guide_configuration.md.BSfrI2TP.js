import{_ as t,c as o,o as a,ae as d}from"./chunks/framework.U1Gow_7P.js";const f=JSON.parse('{"title":"Configuration","description":"","frontmatter":{},"headers":[],"relativePath":"guide/configuration.md","filePath":"en/guide/configuration.md"}'),r={name:"guide/configuration.md"};function c(i,e,l,n,h,s){return a(),o("div",null,e[0]||(e[0]=[d('<h1 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h1><p>This is the documentation for <code>clice.toml</code>.</p><h2 id="server" tabindex="-1">Server <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Server&quot;">​</a></h2><h2 id="rule" tabindex="-1">Rule <a class="header-anchor" href="#rule" aria-label="Permalink to &quot;Rule&quot;">​</a></h2><p><code>[[rules]]</code> represents an array of objects, where each object has the following properties: <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th></tr></thead><tbody><tr><td><code>[rules].pattern</code></td><td><code>array</code> of <code>string</code></td></tr></tbody></table><p>Glob patterns for matching file paths, following LSP&#39;s <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentFilter" target="_blank" rel="noreferrer">standard</a>.</p><ul><li><code>*</code>: Matches one or more characters in a path segment.</li><li><code>?</code>: Matches a single character in a path segment.</li><li><code>**</code>: Matches any number of path segments, including zero.</li><li><code>{}</code>: Used for grouping conditions (e.g., <code>**/*.{ts,js}</code> matches all TypeScript and JavaScript files).</li><li><code>[]</code>: Declares a character range to match in a path segment (e.g., <code>example.[0-9]</code> matches <code>example.0</code>, <code>example.1</code>, etc.).</li><li><code>[!...]</code>: Excludes a character range to match in a path segment (e.g., <code>example.[!0-9]</code> matches <code>example.a</code>, <code>example.b</code>, but not <code>example.0</code>). <br></li></ul><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].append</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>Commands to append to the original command list. For example, <code>append = [&quot;-std=c++17&quot;]</code>. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].remove</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>Commands to remove from the original command list. For example, <code>remove = [&quot;-std=c++11&quot;]</code>. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].readonly</code></td><td><code>string</code></td><td><code>&quot;auto&quot;</code></td></tr></tbody></table><p>Controls whether the file is treated as read-only. Values can be one of <code>&quot;auto&quot;</code>, <code>&quot;always&quot;</code>, and <code>&quot;never&quot;</code>.</p><ul><li><code>&quot;auto&quot;</code>: The file is treated as read-only before you edit it.</li><li><code>&quot;always&quot;</code>: Always treat the file as read-only.</li><li><code>&quot;never&quot;</code>: Always treat the file as non-read-only.</li></ul><p>Read-only means the file is not editable, and LSP requests like code actions or completions won&#39;t be triggered on it. This avoids dynamic computation and allows direct loading of pre-indexed results, improving performance. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].header</code></td><td><code>string</code></td><td><code>&quot;auto&quot;</code></td></tr></tbody></table><p>Controls how to handle header files. Values can be one of <code>&quot;auto&quot;</code>, <code>&quot;always&quot;</code>, and <code>&quot;never&quot;</code>.</p><ul><li><code>&quot;auto&quot;</code>: First try to infer header file context. If no header file context is found, the file will be treated as a regular source file.</li><li><code>&quot;always&quot;</code>: Always treat the file as a header file. If no header file context is found, an error will be reported.</li><li><code>&quot;never&quot;</code>: Always treat the file as a source file.</li></ul><p>Header file context refers to the source files or other metadata associated with that header file. <br></p><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>[rules].contexts</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>Specify additional header file contexts (file paths) for the file.</p><p>Usually, once a file is indexed, header file context is automatically inferred. However, if you need immediate context before indexing is complete, you can manually provide it using this field.</p><h2 id="cache" tabindex="-1">Cache <a class="header-anchor" href="#cache" aria-label="Permalink to &quot;Cache&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>cache.dir</code></td><td><code>string</code></td><td><code>&quot;${workspace}/.clice/cache&quot;</code></td></tr></tbody></table><p>Folder for storing PCH and PCM caches. <br></p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;Index&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr><td><code>index.dir</code></td><td><code>string</code></td><td><code>&quot;${workspace}/.clice/index&quot;</code></td></tr></tbody></table><p>Folder for storing index files. <br></p><h2 id="feature" tabindex="-1">Feature <a class="header-anchor" href="#feature" aria-label="Permalink to &quot;Feature&quot;">​</a></h2>',30)]))}const p=t(r,[["render",c]]);export{f as __pageData,p as default};
