import{_ as e,c as o,o as d,ae as a}from"./chunks/framework.U1Gow_7P.js";const b=JSON.parse('{"title":"Configuration","description":"","frontmatter":{},"headers":[],"relativePath":"zh/guide/configuration.md","filePath":"zh/guide/configuration.md"}'),c={name:"zh/guide/configuration.md"};function r(i,t,l,h,u,n){return d(),o("div",null,t[0]||(t[0]=[a('<h1 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h1><p>这是 <code>clice.toml</code> 的文档。</p><h2 id="server" tabindex="-1">Server <a class="header-anchor" href="#server" aria-label="Permalink to &quot;Server&quot;">​</a></h2><h2 id="rule" tabindex="-1">Rule <a class="header-anchor" href="#rule" aria-label="Permalink to &quot;Rule&quot;">​</a></h2><p><code>[[rules]]</code> 表示一个对象数组，其中每个对象都拥有下面这些属性 <br></p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th></tr></thead><tbody><tr><td><code>[rules].pattern</code></td><td><code>array</code> of <code>string</code></td></tr></tbody></table><p>用于匹配文件路径的 glob patterns，遵循 LSP 的 <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentFilter" target="_blank" rel="noreferrer">标准</a>。</p><ul><li><code>*</code>: 匹配路径段中的一个或多个字符。</li><li><code>?</code>: 匹配路径段中的单个字符。</li><li><code>**</code>: 匹配任意数量的路径段，包括零个。</li><li><code>{}</code>: 用于分组条件 (例如, <code>**/*.{ts,js}</code> 匹配所有 TypeScript 和 JavaScript 文件)。</li><li><code>[]</code>: 声明要匹配的路径段中的字符范围 (例如, <code>example.[0-9]</code> 匹配 <code>example.0</code>, <code>example.1</code> 等)。</li><li><code>[!...]</code>: 排除要匹配的路径段中的字符范围 (例如, <code>example.[!0-9]</code> 匹配 <code>example.a</code>, <code>example.b</code>，但不匹配 <code>example.0</code>)。 <br></li></ul><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>[rules].append</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>追加到原始命令列表中的命令。例如，<code>append = [&quot;-std=c++17&quot;]</code>。 <br></p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>[rules].remove</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>从原始命令列表中移除的命令。例如，<code>remove = [&quot;-std=c++11&quot;]</code>。 <br></p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>[rules].readonly</code></td><td><code>string</code></td><td><code>&quot;auto&quot;</code></td></tr></tbody></table><p>控制文件是否被视为只读。值可以是 <code>&quot;auto&quot;</code>、<code>&quot;always&quot;</code> 和 <code>&quot;never&quot;</code> 中的一个。</p><ul><li><code>&quot;auto&quot;</code>: 在你编辑文件之前，文件被视为只读。</li><li><code>&quot;always&quot;</code>: 始终将文件视为只读。</li><li><code>&quot;never&quot;</code>: 始终将文件视为非只读。</li></ul><p>只读意味着文件不可编辑，并且像代码操作 (code actions) 或补全 (completions) 这样的 LSP 请求不会在其上触发。这避免了动态计算，并允许直接加载预先索引的结果，从而提高性能。 <br></p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>[rules].header</code></td><td><code>string</code></td><td><code>&quot;auto&quot;</code></td></tr></tbody></table><p>控制如何处理头文件。值可以是 <code>&quot;auto&quot;</code>、<code>&quot;always&quot;</code> 和 <code>&quot;never&quot;</code> 中的一个。</p><ul><li><code>&quot;auto&quot;</code>: 首先尝试推断头文件上下文。如果未找到头文件上下文，文件将被视为普通的源文件。</li><li><code>&quot;always&quot;</code>: 始终将文件视为头文件。如果未找到头文件上下文，将会报告错误。</li><li><code>&quot;never&quot;</code>: 始终将文件视为源文件。</li></ul><p>头文件上下文指的是与该头文件相关联的源文件或其他元数据。 <br></p><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>[rules].contexts</code></td><td><code>array</code> of <code>string</code></td><td><code>[]</code></td></tr></tbody></table><p>为文件指定额外的头文件上下文 (文件路径)。</p><p>通常，一旦文件被索引，头文件上下文会自动推断。但是，如果你需要在索引完成前获得即时上下文，可以使用此字段手动提供。</p><h2 id="cache" tabindex="-1">Cache <a class="header-anchor" href="#cache" aria-label="Permalink to &quot;Cache&quot;">​</a></h2><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>cache.dir</code></td><td><code>string</code></td><td><code>&quot;${workspace}/.clice/cache&quot;</code></td></tr></tbody></table><p>用于储存 PCH 和 PCM 缓存的文件夹。 <br></p><h2 id="index" tabindex="-1">Index <a class="header-anchor" href="#index" aria-label="Permalink to &quot;Index&quot;">​</a></h2><table tabindex="0"><thead><tr><th>名称</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td><code>index.dir</code></td><td><code>string</code></td><td><code>&quot;${workspace}/.clice/index&quot;</code></td></tr></tbody></table><p>用于储存索引文件的文件夹。 <br></p><h2 id="feature" tabindex="-1">Feature <a class="header-anchor" href="#feature" aria-label="Permalink to &quot;Feature&quot;">​</a></h2>',30)]))}const p=e(c,[["render",r]]);export{b as __pageData,p as default};
