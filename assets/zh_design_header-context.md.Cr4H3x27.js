import{_ as a,c as i,o as e,ae as n}from"./chunks/framework.U1Gow_7P.js";const r=JSON.parse('{"title":"Header Context","description":"","frontmatter":{},"headers":[],"relativePath":"zh/design/header-context.md","filePath":"zh/design/header-context.md"}'),p={name:"zh/design/header-context.md"};function t(l,s,c,d,h,o){return e(),i("div",null,s[0]||(s[0]=[n(`<h1 id="header-context" tabindex="-1">Header Context <a class="header-anchor" href="#header-context" aria-label="Permalink to &quot;Header Context&quot;">​</a></h1><p>为了让 clangd 正常工作，用户往往需要提供一份<code>compile_commands.json</code>文件（后文简称 CDB 文件）。C++ 的传统编译模型的基本编译单元是一个源文件（例如<code>.c</code>和<code>.cpp</code>文件），<code>#include</code>只是把头文件的内容粘贴复制到源文件中对应的位置。而上述 CDB 文件里面就储存了各个源文件对应编译命令，当你打开一个源文件的时候，clangd 会使用其在 CDB 中对应的编译命令来编译这个文件。</p><p>那很自然的就有一个疑问，如果 CDB 文件里面只有源文件的编译命令，没有头文件的，那么 clangd 是如何处理头文件的呢？clangd 会把头文件当做一个源文件进行处理，然后呢，根据一些规则，比如使用对应目录下的源文件的编译命令作为该头文件的编译命令。这样的模型简单有效，但是却忽略了一些情况。</p><p>由于头文件是源文件的一部分，那么就会出现它的内容根据它在源文件中前面的内容不同而不同的情况。例如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TEST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#else</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ... };</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TEST</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// c.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span></code></pre></div><p>显然，<code>a.h</code>在<code>b.cpp</code>和<code>c.cpp</code>中具有不同的状态，一个定义了<code>X</code>，一个定义了<code>Y</code>，如果简单的把<code>a.h</code>当做一个源文件进行处理，那么就只能看得到<code>Y</code>。</p><p>一个更极端的情况是 non-self-contained 头文件，例如：</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a.h</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    X x;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// b.cpp</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> X</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;a.h&quot;</span></span></code></pre></div><p><code>a.h</code>自身不能被编译，但是嵌入到<code>b.cpp</code>中的时候就编译正常了。这种情况下 clangd 会在<code>a.h</code>中报错，找不到<code>X</code>的定义。显然这是因为它把<code>a.h</code>当成一个独立的源文件了。在 libstdc++ 中的代码中就有很多这样的头文件，现在流行的一些 C++ 的 header-only 的库也有些有这样的代码，clangd 目前无法处理它们。</p><p>clice 将会支持<strong>头文件上下文 (header context)</strong>，支持自动和用户主动切换头文件的状态，当然也会支持非自包含的头文件。我们想要实现如下的效果，以最开始那份代码为例。当你从<code>b.cpp</code>跳转到<code>a.h</code>的时候使用<code>b.cpp</code>作为<code>a.h</code>的上下文。同理，当你从<code>c.cpp</code>跳转到<code>a.h</code>的时候则使用<code>c.cpp</code>作为<code>a.h</code>的上下文。</p>`,10)]))}const g=a(p,[["render",t]]);export{r as __pageData,g as default};
